{"meta":{"title":"星星堆满天","subtitle":"也不能比月圆","description":"这是一个无聊的博客","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"歌单","date":"2021-11-08T13:26:07.000Z","updated":"2021-11-08T15:01:07.278Z","comments":true,"path":"playlist/index.html","permalink":"http://example.com/playlist/index.html","excerpt":"","text":""}],"posts":[{"title":"linux网络编程","slug":"套接字编程","date":"2021-11-18T13:17:05.990Z","updated":"2021-11-18T13:26:38.056Z","comments":true,"path":"2021/11/18/套接字编程/","link":"","permalink":"http://example.com/2021/11/18/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/","excerpt":"","text":"多进程服务器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#define PORT 8888 /*侦听端口地址*/#define BACKLOG 2 /*侦听队列长度*/void process_conn_server(int s)&#123; ssize_t size = 0; char buffer[1024]; /*数据的缓冲区*/ for(;;)&#123; /*循环处理过程*/ memset(buffer,0,sizeof(buffer));/*清空之前的buffer存的数据*/ size = read(s, buffer, 1024); /*从套接字中读取数据放到 缓冲区buffer中*/ if(size == 0)&#123; /*没有数据*/ printf(&quot;客户端已经断开了连接&quot;); return; &#125; /*打印收到的客户端的字符串*/ printf(&quot;client say:%s\\n&quot;,buffer); /*构建响应字符，为接收到客户端字节的数量*/ sprintf(buffer, &quot;%ld bytes altogether\\n&quot;, size); write(s, buffer, strlen(buffer)+1);/*发给客户端,让客户端知道服务器端已经收到它的消息*/ &#125; &#125;int main(int argc, char *argv[])&#123; int ss,sc; /*ss为服务器的socket描述符，sc为客户端的socket描述符*/ struct sockaddr_in server_addr; /*服务器地址结构*/ struct sockaddr_in client_addr; /*客户端地址结构*/ int err; /*返回值*/ pid_t pid; /*分叉的进行ID*/ /*建立一个流式套接字*//*创建监听的套接字*/ ss = socket(AF_INET, SOCK_STREAM, 0); if(ss &lt; 0)&#123; /*出错*/ printf(&quot;socket error\\n&quot;); return -1; &#125; /*设置服务器地址*//*绑定本地的IP port*/ bzero(&amp;server_addr, sizeof(server_addr)); /*清零*/ server_addr.sin_family = AF_INET; /*协议族*/ server_addr.sin_addr.s_addr = htonl(INADDR_ANY);/*转换成大端*/ /*本地地址*/ server_addr.sin_port = htons(PORT); /*服务器端口*/ /*绑定地址结构到套接字描述符*/ err = bind(ss, (struct sockaddr*)&amp;server_addr, sizeof(server_addr)); if(err &lt; 0)&#123;/*出错*/ printf(&quot;bind error\\n&quot;); return -1; &#125; /*设置侦听*/ err = listen(ss, BACKLOG);/*监听的文件描述符,同时能够检测到连接的最大数*/ if(err &lt; 0)&#123; /*出错*/ printf(&quot;listen error\\n&quot;); return -1; &#125; /*主循环过程*/ for(;;) &#123; socklen_t addrlen = sizeof(struct sockaddr); sc = accept(ss, (struct sockaddr*)&amp;client_addr, &amp;addrlen); /*接收客户端连接*/ if(sc &lt; 0)&#123; /*出错*/ continue; /*结束本次循环*/ &#125; /*建立一个新的进程处理到来的连接*/ pid = fork(); /*分叉进程*/ if( pid == 0 )&#123; /*子进程中*/ process_conn_server(sc); /*处理连接*/ close(ss); /*在子进程中关闭服务器的侦听*/ &#125;else&#123; close(sc); /*在父进程中关闭客户端的连接*/ &#125; &#125;&#125; 多线程服务器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#define PORT 8888 /*侦听端口地址*/#define BACKLOG 2 /*侦听队列长度*/void process_conn_server(int s)&#123; ssize_t size = 0; char buffer[1024]; /*数据的缓冲区*/ for(;;)&#123; /*循环处理过程*/ memset(buffer,0,sizeof(buffer));/*清空之前的buffer存的数据*/ size = read(s, buffer, 1024); /*从套接字中读取数据放到 缓冲区buffer中*/ if(size == 0)&#123; /*没有数据*/ printf(&quot;客户端已经断开了连接&quot;); return; &#125; /*打印收到的客户端的字符串*/ printf(&quot;client%d say:%s\\n&quot;,s,buffer); /*构建响应字符，为接收到客户端字节的数量*/ sprintf(buffer, &quot;%ld bytes altogether\\n&quot;, size); write(s, buffer, strlen(buffer)+1);/*发给客户端,让客户端知道服务器端已经收到它的消息*/ &#125; close(s); &#125;int main(int argc, char *argv[])&#123; int ss,sc; /*ss为服务器的socket描述符，sc为客户端的socket描述符*/ struct sockaddr_in server_addr; /*服务器地址结构*/ struct sockaddr_in client_addr; /*客户端地址结构*/ int err; /*返回值*/ pid_t pid; /*分叉的进行ID*/ /*建立一个流式套接字*//*创建监听的套接字*/ ss = socket(AF_INET, SOCK_STREAM, 0); if(ss &lt; 0)&#123; /*出错*/ printf(&quot;socket error\\n&quot;); return -1; &#125; /*设置服务器地址*//*绑定本地的IP port*/ bzero(&amp;server_addr, sizeof(server_addr)); /*清零*/ server_addr.sin_family = AF_INET; /*协议族*/ server_addr.sin_addr.s_addr = htonl(INADDR_ANY);/*转换成大端*/ /*本地地址*/ server_addr.sin_port = htons(PORT); /*服务器端口*/ /*绑定地址结构到套接字描述符*/ err = bind(ss, (struct sockaddr*)&amp;server_addr, sizeof(server_addr)); if(err &lt; 0)&#123;/*出错*/ printf(&quot;bind error\\n&quot;); return -1; &#125; /*设置侦听*/ err = listen(ss, BACKLOG);/*监听的文件描述符,同时能够检测到连接的最大数*/ if(err &lt; 0)&#123; /*出错*/ printf(&quot;listen error\\n&quot;); return -1; &#125; /*主循环过程*/ for(;;) &#123; socklen_t addrlen = sizeof(struct sockaddr); sc = accept(ss, (struct sockaddr*)&amp;client_addr, &amp;addrlen); //第二个参数是一个结构体，封装客户端的地址结构，最后一参数是结构体的长度 /*接收客户端连接*/ if(sc &lt; 0)&#123; /*出错*/ continue; /*结束本次循环*/&#125; pthread_t tid; pthread_create(&amp;tid,NULL,process_conn_server,sc); pthread_detach(tid); &#125; close(ss); &#125; io复用select 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; #include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt; #include &lt;unistd.h&gt;#include &lt;fcntl.h&gt; #define SERV_PORT 8888#define MAX_LISTEN_QUE 5 #define MAX_BUFFER_SIZE 1024 #define RT_ERR (-1)#define RT_OK 0//创建套接字的函数int Ipv4_tcp_create_socket(void)&#123; int listenfd,sockfd,opt=1; struct sockaddr_in server,client; socklen_t len; int temp; int ret; //创建套接字 listenfd = socket(AF_INET,SOCK_STREAM,0);//ipv4，全双工 if(listenfd &lt; 0) &#123; perror(&quot;Create socket fail\\n&quot;); return RT_ERR; &#125; //设置地址重用 if((ret = setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,sizeof(opt))) &lt; 0) &#123; perror(&quot;Error , set socket reuse addr failued\\n&quot;); return RT_ERR; &#125; //初始化服务器端 bzero(&amp;server,sizeof(server)); server.sin_family = AF_INET; server.sin_port = htons(SERV_PORT);//8888 server.sin_addr.s_addr = htonl(INADDR_ANY);//连接所有的客户端 len = sizeof(struct sockaddr); if(bind(listenfd,(struct sockaddr *)&amp;server,len) &lt; 0)&#123; perror(&quot;bind error\\n&quot;); return RT_ERR; &#125; listen(listenfd,MAX_LISTEN_QUE); return listenfd; &#125; int main(int argc,char *argv[])&#123; int listenfd,sockfd; struct sockaddr_in server,client; socklen_t len; int bytes = 0; fd_set g_rdfs,cur_rdfs; int maxfd; int i; char buf[MAX_BUFFER_SIZE]; //获得套接字的极限值 int client_fd[FD_SETSIZE]; printf(&quot;FD_SETSIZE:%d\\n&quot;,FD_SETSIZE); len = sizeof(struct sockaddr_in); //调用创建套接字函数 listenfd = Ipv4_tcp_create_socket(); //将c_rdfs清零 FD_ZERO(&amp;g_rdfs); //将listendfd添加进c_rdfs中 FD_SET(listenfd,&amp;g_rdfs); maxfd = listenfd; //赋初值 for(i = 0;i &lt; FD_SETSIZE; i++) &#123; client_fd[i] = -1; &#125; while(1) &#123; cur_rdfs = g_rdfs;//备份,这个是输出的套接字集合? //监控套接字 if(select(maxfd + 1,&amp;cur_rdfs,NULL,NULL,NULL) &lt; 0)&#123; perror(&quot;select error\\n&quot;); return RT_ERR; &#125; //判断监听套接字是否在检测集中 if(FD_ISSET(listenfd,&amp;cur_rdfs))&#123; //接收套接字（返回的是通信套接字） if((sockfd = accept(listenfd,(struct sockaddr*)&amp;client,(socklen_t*)&amp;len)) &lt; 0)&#123; perror(&quot;accept error\\n&quot;); return RT_ERR; &#125; printf(&quot;sockfd:%d\\n&quot;,sockfd); //清除我们添加进去的套接字，以防下次循环再次检测到 FD_CLR(listenfd,&amp;cur_rdfs); //得到最大的套接字的个数 maxfd = maxfd &gt; sockfd ? maxfd : sockfd; //将通信套接字加入关注的套接字集 FD_SET(sockfd,&amp;g_rdfs); //下面的for语句整体的作用是找到我们的通信套接字并将它的值赋值给存储套接字的数组 //（大家都应该知道前三个套接字都不是我们的通信套接字，第四个才是） for(i = 0; i &lt; maxfd; i++)&#123; if(-1 == client_fd[i])&#123; client_fd[i] = sockfd; break; &#125; &#125; &#125; for(i=0;i &lt;= maxfd;i++)&#123; if(-1 == client_fd[i])&#123; continue; &#125; //判断cur_rdfs是不是在我们关注的读写套接字中 if(FD_ISSET(client_fd[i],&amp;cur_rdfs))&#123; memset(buf,0,MAX_BUFFER_SIZE); printf(&quot;read socket :%d\\n&quot;,client_fd[i]); //如果不是监听套接字我就直接读取数据 bytes = recv(client_fd[i],buf,MAX_BUFFER_SIZE,0); if(bytes &lt; 0)&#123; perror(&quot;recv error\\n&quot;); return RT_ERR; &#125; if(bytes == 0)&#123; //客户端退出，从我关注的套接字集中把它清掉 FD_CLR(client_fd[i],&amp;g_rdfs); //关闭套接字 close(client_fd[i]); client_fd[i] = -1; continue; &#125; //打印读取到的内容 printf(&quot;buf:%s\\n&quot;,buf); //把客户端发送出数据，发送给客户端 send(client_fd[i],buf,strlen(buf),0); &#125; &#125; &#125;&#125; 客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#define PORT 8888 /*侦听端口地址*//*客户端的处理过程*/void process_conn_client(int s)&#123; ssize_t size = 0; char buffer[1024]; /*数据的缓冲区*/ for(;;)&#123; /*循环处理过程*/ memset(buffer,0,sizeof(buffer));/*清空之前的buffer存的数据*/ /*从标准输入中读取数据放到缓冲区buffer中*/ size = read(0, buffer, 1024); if(size &gt; 0)&#123; /*如果读到数据*/ write(s, buffer, size); /*发送给服务器,之前已经通过connect连接好了，然后就可以开始通信*/ size = read(s, buffer, 1024); /*从服务器读取数据,注释了以后客户端就不会重复输出了*/ /*write(1, buffer, size);*/ printf(&quot;server accepted:%s\\n&quot;,buffer); /*写到标准输出*/ &#125;else if(size==0)&#123; printf(&quot;服务器端已经断开了连接...\\n&quot;); break; &#125; &#125; &#125;int main(int argc, char *argv[])&#123; int s; /*s为socket描述符*/ struct sockaddr_in server_addr; /*服务器地址结构*/ /*创建通信的套接字*/ s = socket(AF_INET, SOCK_STREAM, 0); /*建立一个流式套接字 af一个地址描述，type新套接口类型描述，protocol 套接口所用的协议 */ if(s &lt; 0)&#123; /*出错*/ printf(&quot;socket error\\n&quot;); return -1; &#125; /*设置服务器地址*/ bzero(&amp;server_addr, sizeof(server_addr)); /*清零*/ server_addr.sin_family = AF_INET; /*协议族*/ server_addr.sin_addr.s_addr = htonl(INADDR_ANY); /*本地地址*/ server_addr.sin_port = htons(PORT); /*服务器端口,进行一个主机的连接，可以用127.0.0.1*/ /*将用户输入的字符串类型的IP地址转为整型,大端模式*/ inet_pton(AF_INET, argv[1], &amp;server_addr.sin_addr); /*连接服务器*/ connect(s, (struct sockaddr*)&amp;server_addr, sizeof(struct sockaddr)); process_conn_client(s); /*客户端处理过程*/ close(s); /*关闭连接,只需要关闭通信套接字，和服务器不一样，服务器要关闭监听和通信套接字*/ return 0;&#125; web服务器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;//linux 系统上网络相关#include&lt;arpa/inet.h&gt;#include&lt;sys/socket.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#define PORT 8080 /*侦听端口地址*///准备连接，返回服务器的Fd int initServer();//处理客户端的连接 void handClient(int fd); int main()&#123;//1.实现连接int serverFd=initServer(); int clientFd; struct sockaddr_in caddr;pid_t pid;//2.处理请求while(1)&#123; //1.等待客户端连接 //memset(&amp;caddr,0,size); socklen_t size= sizeof(caddr); clientFd= accept(serverFd,(struct sockaddr*)&amp;caddr,&amp;size); if(clientFd &lt; 0)&#123; /*出错*/ continue; /*结束本次循环*/&#125; pthread_t tid; printf(&quot;客户端%d连接服务器了！\\n&quot;,clientFd); pthread_create(&amp;tid,NULL,handClient,clientFd); pthread_detach(tid);&#125; close(serverFd); &#125;//做好连接的准备工作 完成tcp的前四步，并返回服务器的fd int initServer()&#123; //1.创建 socketFd socket网络套接字 FD是文件描述符 int fd=socket(AF_INET,SOCK_STREAM,0);//第二个参数是数据类型 流式套接字？ if (fd==-1)&#123; perror(&quot;创建socket失败：&quot;); return -1; &#125; printf(&quot;创建socket成功！\\n&quot;); //不阻塞使用setsockopt函数设置一下fd的工作状态 int n=1; setsockopt(fd,SOL_SOCKET,SO_REUSEADDR,&amp;n,4); //2.设置服务器的协议地址族 //确定服务器 是在哪台电脑上的哪个应用程序 struct sockaddr_in addr=&#123;0&#125;; addr.sin_family=AF_INET;//与socket函数第一个参数一致 addr.sin_port=htons(PORT);//所有的浏览器 都是这个端口 浏览器专用80端口 //htons(8080)小端转大端 addr.sin_addr.s_addr=INADDR_ANY;//当前电脑上任意网卡都可以 //3.绑定 int r=bind(fd,(struct sockaddr*)&amp;addr,sizeof(addr)); if(r == -1)&#123; perror(&quot;绑定失败&quot;); close(fd); return -1; &#125; printf(&quot;绑定成功！\\n&quot;); //4.监听 r= listen(fd,10); if(r == -1)&#123; perror(&quot;监听失败&quot;); close(fd); return -1; &#125; printf(&quot;监听成功！\\n&quot;); return fd; &#125; void handClient(int fd)&#123; //接收客户端发来的信息 char buff[1024*1024]=&#123;0&#125;;//1M int r=read(fd,buff,sizeof(buff)); if(r&gt;0) printf(&quot;接收到客户端发来的请求：\\n%s\\n&quot;,buff); char filename[20]=&#123;0&#125;; sscanf(buff,&quot;GET /%s&quot;,filename); printf(&quot;解析出的文件名为：%s\\r\\n\\r\\n&quot;,filename); //根据文件名 得到 文件类型，告诉浏览器 发送什么文件 char* mime =NULL; if(strstr(filename,&quot;.html&quot;))&#123; mime=&quot;text/html&quot;;//文本或者html类型 &#125; else if (strstr(filename,&quot;.jpg&quot;))&#123; mime =&quot;image/jpg&quot;; &#125; char response[1024*1024]=&#123;0&#125;;//响应头 sprintf(response,&quot;HTTP/1.1 200 OK \\r\\nContent-Type:%s\\r\\n\\r\\n&quot;,mime); int responseLen=strlen(response); int fileFd = open(filename,O_RDONLY); int fileLen= read(fileFd,responseLen+response, sizeof(response)-responseLen); write(fd,response,responseLen+fileLen); close(fileFd); sleep(1); &#125;","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"测试","slug":"测试","date":"2021-11-12T13:20:15.000Z","updated":"2021-11-12T13:25:15.730Z","comments":true,"path":"2021/11/12/测试/","link":"","permalink":"http://example.com/2021/11/12/%E6%B5%8B%E8%AF%95/","excerpt":"","text":"这是一个test 我要上传图片啦，希望它不会挂掉。 一个疑问：为什么刚生成一个md文件的时候 typora不能正常打字","categories":[],"tags":[]},{"title":"好想去看雪","slug":"好想去看雪","date":"2021-11-08T05:20:25.000Z","updated":"2021-11-08T17:14:01.285Z","comments":true,"path":"2021/11/08/好想去看雪/","link":"","permalink":"http://example.com/2021/11/08/%E5%A5%BD%E6%83%B3%E5%8E%BB%E7%9C%8B%E9%9B%AA/","excerpt":"","text":"I’m so glad you made time to see me How’s life, tell me how’s your family I haven’t seen them in a while You’ve been good, busier than ever We small talk, work and the weather Your guard is up and I know why Because the last time you saw me is still burned in the back of your mind You gave me roses and I left them there to die So this is me swallowing my pride Standing in front of you saying I’m sorry for that night And I go back to December all the time It turns out freedom ain’t nothing but missing you Wishing I’d realized what I had when you were mine I go back to December, turn around and make it alright I go back to December all the time These days I haven’t been sleeping Staying up playing back myself leaving When your birthday passed and I didn’t call Then I think about summer, all the beautiful times I watched you laughing from the passenger side And realized I loved you in the fall And then the cold came, the dark days when fear crept into my mind You gave me all your love and all I gave you was goodbye So this is me swallowing my pride Standing in front of you saying I’m sorry for that night And I go back to December all the time It turns out freedom ain’t nothing but missing you Wishing I’d realized what I had when you were mine I go back to December, turn around and change my own mind I go back to December all the time I miss your tan skin, your sweet smile, so good to me, so right And how you held me in your arms that September night The first time you ever saw me cry Maybe this is wishful thinking Probably mindless dreaming But if we loved again, I swear I’d love you right I’d go back in time and change it, but I can’t So if the chain is on your door I understand But this is me swallowing my pride Standing in front of you saying I’m sorry for that night And I go back to December It turns out freedom ain’t nothing but missing you Wishing I’d realized what I had when you were mine I go back to December turn around and make it alright I go back to December, turn around and change my own mind I go back to December all the time All the time 以上，分享一首很有冬天氛围的歌《Back To December》 就，看到北方同学的雪景图，突然就好想去看雪！","categories":[],"tags":[{"name":"日常","slug":"日常","permalink":"http://example.com/tags/%E6%97%A5%E5%B8%B8/"}]}],"categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"日常","slug":"日常","permalink":"http://example.com/tags/%E6%97%A5%E5%B8%B8/"}]}